<task id="_bmad/core/tasks/workflow.xml" name="Execute Workflow">
  <objective>Execute given workflow by loading its configuration, following instructions, and producing output</objective>

  <llm critical="true">
    <mandate>Always read COMPLETE files - NEVER use offset/limit when reading any workflow related files</mandate>
    <mandate>Instructions are MANDATORY - either as file path, steps or embedded list in YAML, XML or markdown</mandate>
    <mandate>Execute ALL steps in instructions IN EXACT ORDER</mandate>
    <mandate>Save to template output file after EVERY "template-output" tag</mandate>
    <mandate>NEVER skip a step - YOU are responsible for every steps execution without fail or excuse</mandate>
  </llm>

  <WORKFLOW-RULES critical="true">
    <rule n="1">Steps execute in exact numerical order (1, 2, 3...)</rule>
    <rule n="2">Optional steps: Ask user unless #yolo mode active</rule>
    <rule n="3">Template-output tags: Save content, discuss with the user the section completed, and NEVER proceed until the users indicates
      to proceed (unless YOLO mode has been activated)</rule>
  </WORKFLOW-RULES>

  <flow>
    <step n="1" title="Load and Initialize Workflow">
      <substep n="1a" title="Load Configuration and Resolve Variables">
        <action>Read workflow.yaml from provided path</action>
        <mandate>Load config_source (REQUIRED for all modules)</mandate>
        <phase n="1">Load external config from config_source path</phase>
        <phase n="2">Resolve all {config_source}: references with values from config</phase>
        <phase n="3">Resolve system variables (date:system-generated) and paths ({project-root}, {installed_path})</phase>
        <phase n="4">Ask user for input of any variables that are still unknown</phase>
      </substep>

      <substep n="1b" title="Load Required Components">
        <mandate>Instructions: Read COMPLETE file from path OR embedded list (REQUIRED)</mandate>
        <check>If template path ‚Üí Read COMPLETE template file</check>
        <check>If validation path ‚Üí Note path for later loading when needed</check>
        <check>If template: false ‚Üí Mark as action-workflow (else template-workflow)</check>
        <note>Data files (csv, json) ‚Üí Store paths only, load on-demand when instructions reference them</note>
      </substep>

      <substep n="1c" title="Initialize Output" if="template-workflow">
        <action>Resolve default_output_file path with all variables and {{date}}</action>
        <action>Create output directory if doesn't exist</action>
        <action>If template-workflow ‚Üí Write template to output file with placeholders</action>
        <action>If action-workflow ‚Üí Skip file creation</action>
      </substep>
    </step>

    <step n="2" title="Process Each Instruction Step in Order">
      <iterate>For each step in instructions:</iterate>

      <substep n="2a" title="Handle Step Attributes">
        <check>If optional="true" and NOT #yolo ‚Üí Ask user to include</check>
        <check>If if="condition" ‚Üí Evaluate condition</check>
        <check>If for-each="item" ‚Üí Repeat step for each item</check>
        <check>If repeat="n" ‚Üí Repeat step n times</check>
      </substep>

      <substep n="2b" title="Execute Step Content">
        <action>Process step instructions (markdown or XML tags)</action>
        <action>Replace {{variables}} with values (ask user if unknown)</action>
        <execute-tags>
          <tag>action xml tag ‚Üí Perform the action</tag>
          <tag>check if="condition" xml tag ‚Üí Conditional block wrapping actions (requires closing &lt;/check&gt;)</tag>
          <tag>ask xml tag ‚Üí Prompt user and WAIT for response</tag>
          <tag>invoke-workflow xml tag ‚Üí Execute another workflow with given inputs and the workflow.xml runner</tag>
          <tag>invoke-task xml tag ‚Üí Execute specified task</tag>
          <tag>invoke-protocol name="protocol_name" xml tag ‚Üí Execute reusable protocol from protocols section</tag>
          <tag>goto step="x" ‚Üí Jump to specified step</tag>
        </execute-tags>
      </substep>

      <substep n="2c" title="Handle template-output Tags">
        <if tag="template-output">
          <mandate>Generate content for this section</mandate>
          <mandate>Save to file (Write first time, Edit subsequent)</mandate>
          <action>Display generated content</action>
          <ask> [a] Advanced Elicitation, [c] Continue, [p] Party-Mode, [y] YOLO the rest of this document only. WAIT for response. <if
              response="a">
              <action>Start the advanced elicitation workflow {project-root}/_bmad/core/workflows/advanced-elicitation/workflow.xml</action>
            </if>
            <if
              response="c">
              <action>Continue to next step</action>
            </if>
            <if response="p">
              <action>Start the party-mode workflow {project-root}/_bmad/core/workflows/party-mode/workflow.yaml</action>
            </if>
            <if
              response="y">
              <action>Enter #yolo mode for the rest of the workflow</action>
            </if>
          </ask>
        </if>
      </substep>

      <substep n="2d" title="Step Completion">
        <check>If no special tags and NOT #yolo:</check>
        <ask>Continue to next step? (y/n/edit)</ask>
      </substep>
    </step>

    <step n="3" title="Completion">
      <check>Confirm document saved to output path</check>
      <action>Report workflow completion</action>
    </step>
  </flow>

  <execution-modes>
    <mode name="normal">Full user interaction and confirmation of EVERY step at EVERY template output - NO EXCEPTIONS except yolo MODE</mode>
    <mode name="yolo">Skip all confirmations and elicitation, minimize prompts and try to produce all of the workflow automatically by
      simulating the remaining discussions with an simulated expert user</mode>
  </execution-modes>

  <supported-tags desc="Instructions can use these tags">
    <structural>
      <tag>step n="X" goal="..." - Define step with number and goal</tag>
      <tag>optional="true" - Step can be skipped</tag>
      <tag>if="condition" - Conditional execution</tag>
      <tag>for-each="collection" - Iterate over items</tag>
      <tag>repeat="n" - Repeat n times</tag>
    </structural>
    <execution>
      <tag>action - Required action to perform</tag>
      <tag>action if="condition" - Single conditional action (inline, no closing tag needed)</tag>
      <tag>check if="condition"&gt;...&lt;/check&gt; - Conditional block wrapping multiple items (closing tag required)</tag>
      <tag>ask - Get user input (ALWAYS wait for response before continuing)</tag>
      <tag>goto - Jump to another step</tag>
      <tag>invoke-workflow - Call another workflow</tag>
      <tag>invoke-task - Call a task</tag>
      <tag>invoke-protocol - Execute a reusable protocol (e.g., discover_inputs)</tag>
    </execution>
    <output>
      <tag>template-output - Save content checkpoint</tag>
      <tag>critical - Cannot be skipped</tag>
      <tag>example - Show example output</tag>
    </output>
  </supported-tags>

  <protocols desc="Reusable workflow protocols that can be invoked via invoke-protocol tag">
    <protocol name="discover_inputs" desc="Smart file discovery and loading based on input_file_patterns">
      <objective>Intelligently load project files (whole or sharded) based on workflow's input_file_patterns configuration</objective>

      <critical>Only execute if workflow.yaml contains input_file_patterns section</critical>

      <flow>
        <step n="1" title="Parse Input File Patterns">
          <action>Read input_file_patterns from loaded workflow.yaml</action>
          <action>For each pattern group (prd, architecture, epics, etc.), note the load_strategy if present</action>
        </step>

        <step n="2" title="Load Files Using Smart Strategies">
          <iterate>For each pattern in input_file_patterns:</iterate>

          <substep n="2a" title="Try Sharded Documents First">
            <check if="sharded pattern exists">
              <action>Determine load_strategy from pattern config (defaults to FULL_LOAD if not specified)</action>

              <strategy name="FULL_LOAD">
                <desc>Load ALL files in sharded directory - used for PRD, Architecture, UX, brownfield docs</desc>
                <action>Use glob pattern to find ALL .md files (e.g., "{output_folder}/*architecture*/*.md")</action>
                <action>Load EVERY matching file completely</action>
                <action>Concatenate content in logical order (index.md first if exists, then alphabetical)</action>
                <action>Store in variable: {pattern_name_content}</action>
              </strategy>

              <strategy name="SELECTIVE_LOAD">
                <desc>Load specific shard using template variable - example: used for epics with {{epic_num}}</desc>
                <action>Check for template variables in sharded_single pattern (e.g., {{epic_num}})</action>
                <action>If variable undefined, ask user for value OR infer from context</action>
                <action>Resolve template to specific file path</action>
                <action>Load that specific file</action>
                <action>Store in variable: {pattern_name_content}</action>
              </strategy>

              <strategy name="INDEX_GUIDED">
                <desc>Load index.md, analyze structure and description of each doc in the index, then intelligently load relevant docs</desc>
                <mandate>DO NOT BE LAZY - use best judgment to load documents that might have relevant information, even if only a 5% chance</mandate>
                <action>Load index.md from sharded directory</action>
                <action>Parse table of contents, links, section headers</action>
                <action>Analyze workflow's purpose and objective</action>
                <action>Identify which linked/referenced documents are likely relevant</action>
                <example>If workflow is about authentication and index shows "Auth Overview", "Payment Setup", "Deployment" ‚Üí Load auth
                  docs, consider deployment docs, skip payment</example>
                <action>Load all identified relevant documents</action>
                <action>Store combined content in variable: {pattern_name_content}</action>
                <note>When in doubt, LOAD IT - context is valuable, being thorough is better than missing critical info</note>
              </strategy>
              <action>Mark pattern as RESOLVED, skip to next pattern</action>
            </check>
          </substep>

          <substep n="2b" title="Try Whole Document if No Sharded Found">
            <check if="no sharded matches found OR no sharded pattern exists">
              <action>Attempt glob match on 'whole' pattern (e.g., "{output_folder}/*prd*.md")</action>
              <check if="matches found">
                <action>Load ALL matching files completely (no offset/limit)</action>
                <action>Store content in variable: {pattern_name_content} (e.g., {prd_content})</action>
                <action>Mark pattern as RESOLVED, skip to next pattern</action>
              </check>
            </check>
          </substep>

          <substep n="2c" title="Handle Not Found">
            <check if="no matches for sharded OR whole">
              <action>Set {pattern_name_content} to empty string</action>
              <action>Note in session: "No {pattern_name} files found" (not an error, just unavailable, offer use change to provide)</action>
            </check>
          </substep>
        </step>

        <step n="3" title="Report Discovery Results">
          <action>List all loaded content variables with file counts</action>
          <example>
            ‚úì Loaded {prd_content} from 5 sharded files: prd/index.md, prd/requirements.md, ...
            ‚úì Loaded {architecture_content} from 1 file: Architecture.md
            ‚úì Loaded {epics_content} from selective load: epics/epic-3.md
            ‚óã No ux_design files found
          </example>
          <note>This gives workflow transparency into what context is available</note>
        </step>
      </flow>

    </protocol>

    <protocol name="detect_worktree" desc="Universal git worktree story detection - compatible with any agent">
      <objective>Detect if running in isolated git worktree and auto-configure story context from .story-id file</objective>

      <critical>This protocol enables AGENT-AGNOSTIC worktree isolation - works with Claude, Qwen, Cursor, Copilot, or any other agent</critical>

      <flow>
        <step n="1" title="Check for Worktree Environment">
          <action>Check if .story-id file exists in current working directory</action>

          <check if=".story-id file exists">
            <action>Read .story-id file content (strip whitespace, trim newlines)</action>
            <action>Store story ID in variable: {worktree_story_id}</action>

            <output>üå≤ **Git Worktree Detected**
              Story ID: {worktree_story_id}
              Mode: Isolated development environment

              **Auto-Configuration:**
              - Using story ID from .story-id file
              - Story context auto-loaded from worktree environment
              - Changes isolated to this worktree
              - PR will be created on completion (not direct merge)
            </output>
          </check>

          <check if=".story-id file does NOT exist">
            <output>‚ÑπÔ∏è No .story-id found - running in main repository
              Standard workflow mode: will search sprint-status for next story
            </output>
            <action>Set {worktree_story_id} = empty</action>
            <action>Skip to step 4 (continue normal workflow)</action>
          </check>
        </step>

        <step n="2" title="Load Worktree Context">
          <check if="{worktree_story_id} is NOT empty">

            <!-- Load story file -->
            <action>Find story file using pattern: {story_dir}/{worktree_story_id}*.md</action>
            <check if="story file found">
              <action>Read COMPLETE story file</action>
              <action>Store story content in variable: {worktree_story_content}</action>
              <action>Extract story title from content</action>
            </check>

            <!-- Load .story-files manifest if exists -->
            <check if=".story-files file exists">
              <action>Read .story-files manifest</action>
              <action>Store manifest content in variable: {worktree_story_files}</action>
              <note>This tracks which files are locked by this story to prevent conflicts</note>
            </check>

            <output>‚úÖ **Worktree Context Loaded**
              Story: {worktree_story_id}
              Files Manifest: {worktree_story_files exists ? 'Loaded' : 'Not found'}
            </output>
          </check>
        </step>

        <step n="3" title="Configure Workflow Variables">
          <check if="{worktree_story_id} is NOT empty">
            <action>Set workflow variable: story_path = path to discovered story file</action>
            <action>Set workflow variable: {{story_path}} = {worktree_story_id} story file path</action>

            <note>These variables override sprint-status search - workflow uses this story directly</note>

            <output>üéØ **Story Auto-Selected**
              File: {story_path}
              All workflow operations will target this story
            </output>
          </check>
        </step>

        <step n="4" title="Conflict Prevention Check">
          <check if="{worktree_story_id} is NOT empty AND .story-files exists">
            <action>Pars storyFiles section from .story-files manifest</action>
            <action>List file patterns locked by this story</action>

            <output>üîí **Conflict Prevention Active**
              Locked Files (from .story-files):
              {list each storyFiles pattern}

              Other agents working on these files should wait until this story is complete
            </output>
          </check>
        </step>
      </flow>

      <agent-compatibility>
        <desc>This protocol works with ANY agent that can read files and parse simple text</desc>

        <support agent="Claude" level="full">File reading via Read tool, bash via Bash tool</support>
        <support agent="Qwen" level="full">Identical capabilities to Claude</support>
        <support agent="Cursor" level="full">Natural file reading and command execution</support>
        <support agent="Copilot" level="full">VS Code extension reads files seamlessly</support>
        <support agent="Custom" level="full">Any agent with file read + execute capabilities</support>
        <support agent="Human" level="full">Manual workflow documented in CONTRIBUTING.md</support>
      </agent-compatibility>

      <integration>
        <title>How to Use This Protocol</title>

        <option n="1" method="Automatic Invocation">
          <desc>Workflows that support worktree auto-detection invoke this protocol in Step 1</desc>
          <example>
            <!-- In workflow instructions.xml -->
            <step n="1" goal="Detect worktree environment">
              <action>invoke-protocol name="detect_worktree"</action>
              <goto step="2" if="story_path already set" />
            </step>
          </example>
        </option>

        <option n="2" method="Manual Setup">
          <desc>Initialize worktree using provided scripts, then run any workflow</desc>
          <example>
            # Linux/Mac
            ./scripts/init-worktree.sh 1-8 agent1
            cd worktrees/agent1-story-1-8

            # Windows
            scripts\init-worktree.bat 1-8 agent1
            cd worktrees\agent1-story-1-8

            # Then run ANY workflow - it auto-detects from .story-id
          </example>
        </option>
      </integration>

      <completion>
        <desc>When story is complete, agent should create PR (not merge directly)</desc>

        <actions>
          <action n="1">Push branch to remote: git push -u origin {branch_name}</action>
          <action n="2">Create PR: gh pr create --title "[Story {story_id}] {title}"</action>
          <action n="3">Wait for PR approval and merge</action>
          <action n="4">Cleanup worktree after merge: git worktree remove {worktree_path}</action>
        </actions>
      </completion>
    </protocol>

    <protocol name="ensure_story_worktree" desc="Ensure story has an isolated git worktree - create if missing">
      <objective>
        For create-story workflow: Check if story already has a dedicated worktree in .git/worktrees/.
        If NOT found, automatically create the worktree for isolated development.
      </objective>

      <critical>This protocol enforces BMad Method worktree isolation policy - EVERY story must have its own worktree</critical>

      <flow>
        <step n="1" title="Check for Existing Worktree">
          <action>Check if .story-id file exists in current working directory</action>

          <check if=".story-id file exists">
            <action>Read .story-id file content (strip whitespace, trim newlines)</action>
            <action>Store story ID in variable: {worktree_story_id}</action>
            <output>üå≤ Already in worktree for story: {worktree_story_id}</output>
            <action>Skip to step 4 (worktree already exists)</action>
          </check>

          <check if=".story-id file does NOT exist">
            <output>‚ÑπÔ∏è Not in a worktree - will check if one exists for target story</output>
            <action>Set {worktree_story_id} = empty</action>
            <action>Continue to step 2</action>
          </check>
        </step>

        <step n="2" title="Determine Target Story Key">
          <action>Get target story key from workflow variables: {{story_key}}</action>

          <check if="{{story_key}} is empty">
            <action>Get target story from user input or sprint-status auto-discovery</action>
            <action>Parse story key from input (format: X-Y-name or epic-X-story-Y)</action>
          </check>

          <output>üéØ Target story: {{story_key}}</output>
        </step>

        <step n="3" title="Check if Worktree Already Exists">
          <action>List all worktrees: git worktree list --porcelain</action>
          <action>Parse output to find worktree paths</action>
          <action>Check if any worktree contains a .story-id file matching {{story_key}}</action>

          <check if="matching worktree found">
            <output>‚úÖ Worktree already exists for story {{story_key}}</output>
            <output>Path: {existing_worktree_path}</output>
            <action>Set {worktree_exists} = true</action>
            <action>Skip to step 5</action>
          </check>

          <check if="no matching worktree found">
            <output>‚ö†Ô∏è No worktree found for story {{story_key}}</output>
            <action>Set {worktree_exists} = false</action>
            <action>Continue to step 4</action>
          </check>
        </step>

        <step n="4" title="Create Worktree if Missing">
          <check if="{worktree_exists} = false">
            <critical>üîß CREATING GIT WORKTREE FOR ISOLATED DEVELOPMENT</critical>

            <action>Determine worktree path: {project-root}/worktrees/story-{{story_key}}</action>
            <action>Determine branch name: story/{{story_key}}</action>

            <output>üìÇ Creating worktree at: {worktree_path}</output>
            <action>Create worktree branch: git worktree add -b {branch_name} {worktree_path} main</action>

            <check if="worktree creation failed">
              <output>‚ùå Failed to create worktree</output>
              <output>Please check git status and try manually</output>
              <action>HALT - Cannot proceed without worktree</action>
            </check>

            <action>Create .story-id file in worktree root: echo "{{story_key}}" > {worktree_path}/.story-id</action>
            <action>Create .story-files manifest (empty for now): touch {worktree_path}/.story-files</action>

            <output>‚úÖ Worktree created successfully!</output>
            <output>Branch: {branch_name}</output>
            <output>Path: {worktree_path}</output>
            <output>Switch to worktree: cd {worktree_path}</output>
          </check>
        </step>

        <step n="5" title="Configure Workflow for Worktree">
          <action>Set workflow variable: {use_worktree} = true</action>
          <action>Set workflow variable: {story_worktree_path} = path to story worktree</action>

          <output>üéØ Worktree protocol complete</output>
          <output>Story: {{story_key}}</output>
          <output>Path: {story_worktree_path}</output>
          <check if="worktree was just created">
            <output>‚ö†Ô∏è IMPORTANT: Switch to worktree directory before continuing!</output>
            <output>cd {story_worktree_path}</output>
          </check>
        </step>
      </flow>
    </protocol>

    <protocol name="require_story_worktree" desc="Require being in correct story worktree - block if not">
      <objective>
        For dev-story workflow: Verify we are running in the correct git worktree for the target story.
        BLOCK execution if not in a worktree or in the wrong worktree.
      </objective>

      <critical>This protocol PREVENTS coding outside of isolated worktree - protects main branch from direct changes</critical>

      <flow>
        <step n="1" title="Check for Worktree Environment">
          <action>Check if .story-id file exists in current working directory</action>

          <check if=".story-id file does NOT exist">
            <critical>üö´ CRITICAL SAFETY VIOLATION</critical>
            <output>
              ‚ùå **NOT IN A WORKTREE - CODING BLOCKED**

              You are attempting to develop a story WITHOUT an isolated git worktree.

              **BMad Method Requirement:**
              - ALL story development MUST happen in dedicated worktrees
              - This prevents branch conflicts and protects main branch

              **To Fix:**
              1. Run the **create-story** workflow first
              2. It will automatically create the worktree for this story
              3. Then run **dev-story** from within that worktree

              **Command:**
              /bmad:bmm:workflows:create-story {{story_key}}

              After create-story completes:
              cd worktrees/story-{{story_key}}
              /bmad:bmm:workflows:dev-story
            </output>
            <action>HALT - Cannot continue without worktree</action>
          </check>

          <action>Read .story-id file content (strip whitespace, trim newlines)</action>
          <action>Store in variable: {current_worktree_story}</action>
        </step>

        <step n="2" title="Verify Worktree Matches Target Story">
          <action>Get target story key from workflow: {{story_key}}</action>

          <check if="{{story_key}} is empty">
            <action>Parse story key from .story-id: {current_worktree_story}</action>
            <action>Set {{story_key}} = {current_worktree_story}</action>
          </check>

          <check if="{current_worktree_story} != {{story_key}}">
            <critical>üö´ WRONG WORKTREE - CODING BLOCKED</critical>
            <output>
              ‚ùå **WRONG WORKTREE DETECTED**

              Current worktree story: {current_worktree_story}
              Target story: {{story_key}}

              **You are in the wrong worktree!**

              **To Fix:**
              - Switch to the correct worktree:
                cd worktrees/story-{{story_key}}

              - Or if that worktree doesn't exist, create it first:
                /bmad:bmm:workflows:create-story {{story_key}}
            </output>
            <action>HALT - Wrong worktree</action>
          </check>

          <output>‚úÖ Correct worktree confirmed for story: {{story_key}}</output>
        </step>

        <step n="3" title="Load Worktree Context">
          <invoke-protocol name="detect_worktree"/>
        </step>
      </flow>
    </protocol>
  </protocols>

  <llm final="true">
    <critical-rules>
      ‚Ä¢ This is the complete workflow execution engine
      ‚Ä¢ You MUST Follow instructions exactly as written
      ‚Ä¢ The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml
      ‚Ä¢ You MUST have already loaded and processed: {installed_path}/workflow.yaml
      ‚Ä¢ This workflow uses INTENT-DRIVEN PLANNING - adapt organically to product type and context
      ‚Ä¢ YOU ARE FACILITATING A CONVERSATION With a user to produce a final document step by step. The whole process is meant to be
      collaborative helping the user flesh out their ideas. Do not rush or optimize and skip any section.
    </critical-rules>
  </llm>
</task> 
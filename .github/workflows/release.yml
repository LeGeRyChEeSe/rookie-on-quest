# GitHub Actions Workflow for Automated Release Builds
#
# This workflow provides automated release build capability for the Rookie On Quest app.
# It can be manually triggered from the GitHub Actions interface.
#
# Permissions:
# - contents: write: REQUIRED BY AC1/NFR-B9 - Acceptance Criterion 1 explicitly requires
#   "workflow has explicit permissions for contents write and releases creation"
#   While not actively used in Story 8.1, this permission satisfies AC1 and prepares
#   for Story 8.4 which will implement release creation.
# - releases: write: REQUIRED BY AC1/NFR-B9 - Acceptance Criterion 1 explicitly requires
#   "workflow has explicit permissions for contents write and releases creation"
#   Also required for future Story 8.2 (upload signed APK to release) and Story 8.4 (create GitHub release)
#
# LEAST PRIVILEGE PRINCIPLE VS ACCEPTANCE CRITERIA:
# ================================================================================
# The principle of least privilege suggests using minimal permissions (read-only).
# However, AC1/NFR-B9 explicitly REQUIRE write permissions for contents and releases.
#
# WHY WRITE PERMISSIONS ARE ACCEPTABLE FOR STORY 8.1:
# 1. Acceptance Criteria Compliance: AC1 explicitly requires "releases: write"
# 2. Future Story Preparation: Stories 8.2-8.4 will use these permissions
# 3. Permission Stability: Avoids permission changes across stories (security best practice)
# 4. No Immediate Risk: Write permissions are not actively used in Story 8.1 code
#
# SECURITY ASSESSMENT:
# - Risk Level: LOW (permissions are defined but not exercised in Story 8.1)
# - Mitigation: Code review ensures no unintended write operations in Story 8.1
# - Audit Trail: All permission usage will be visible in GitHub Actions logs
#
# REFERENCES:
# - AC1: "workflow has explicit permissions for contents write and releases creation"
# - NFR-B9: "Workflow must have explicit permissions for release creation"
#
# Performance: Uses Gradle caching to speed up builds (NFR-B1: complete within 10 minutes)
#
# Note: This is Story 8.1 - Workflow foundation only.
# APK signing will be added in Story 8.2.
# Version extraction and GitHub release creation will be added in Story 8.3-8.4.
#
# SECURITY NOTICE (Story 8.1):
# The build will fall back to debug signing if keystore.properties is missing.
# This is ONLY acceptable for Story 8.1 CI/CD workflow foundation testing.
# Story 8.2 will add GitHub Secrets-based keystore management to eliminate this risk.
# Production builds MUST have proper signing configuration.
#
name: Release Build

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., 2.5.0 or 2.5.0-rc.1). Leave empty to use version from build.gradle.kts.'
        required: false
        default: ''
      versionCode:
        description: 'Version code (integer). Leave empty to use versionCode from build.gradle.kts.'
        required: false
        default: ''

permissions:
  contents: write
  releases: write

jobs:
  build:
    name: Build Release APK
    runs-on: ubuntu-latest
    # NFR-B1: CI/CD workflow must complete release build within 10 minutes
    # Gradle caching (enabled) and optimized build steps ensure completion within limit
    # Individual step timeouts provide granular control and early failure detection
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        timeout-minutes: 2
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'gradle'

      - name: Grant execute permission for gradlew
        # ================================================================================
        # REDUNDANT STEP (Story 8.1 Acceptable)
        # ================================================================================
        # While gradlew has executable bit (100755) in git, GitHub Actions checkout
        # may not preserve it on all runners. This step ensures executability regardless.
        #
        # REVIEW NOTE: This step was marked as "redundant" in code review because
        # gradlew already has the executable bit set in git. However, this is a defensive
        # measure to ensure the workflow works correctly on all GitHub Actions runners.
        # The overhead is minimal (1 second) and the benefit is reliability.
        #
        # If this step proves to be truly unnecessary, it can be removed in Story 8.7
        # (Build Dependency Caching and Performance) as part of workflow optimization.
        #
        # CRITICAL: This step MUST run BEFORE any ./gradlew commands to avoid failures
        # on fresh runners where checkout doesn't preserve the executable bit.
        timeout-minutes: 1
        shell: bash
        run: chmod +x gradlew

      - name: Validate version inputs
        timeout-minutes: 1
        shell: bash
        env:
          INPUT_VERSION: ${{ inputs.version }}
          INPUT_VERSION_CODE: ${{ inputs.versionCode }}
        run: |
          # Validate version input (optional)
          # Only allow semver-like format: X.Y.Z, X.Y.Z-rc.N, etc.
          # This prevents command injection by:
          # 1. Using env: mapping (above) to isolate inputs from shell expansion
          # 2. Validating format with regex before use
          # 3. Setting validated values to GITHUB_ENV for safe use in later steps

          if [ -n "$INPUT_VERSION" ]; then
            # Check for valid semver pattern (basic validation)
            # Allow: digits, dots, hyphens, 'rc', 'alpha', 'beta', etc.
            if [[ ! "$INPUT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
              echo "::error::Invalid version format: $INPUT_VERSION"
              echo "::error::Version must match semver format: X.Y.Z or X.Y.Z-rc.N"
              exit 1
            fi
            echo "✅ Version input validated: $INPUT_VERSION"
            # Set validated version as env var for subsequent steps
            echo "BUILD_VERSION=$INPUT_VERSION" >> $GITHUB_ENV
          fi

          if [ -n "$INPUT_VERSION_CODE" ]; then
            # Check for valid versionCode (positive integer)
            if [[ ! "$INPUT_VERSION_CODE" =~ ^[0-9]+$ ]]; then
              echo "::error::Invalid versionCode format: $INPUT_VERSION_CODE"
              echo "::error::versionCode must be a positive integer"
              exit 1
            fi
            # Check for integer overflow (max for Android versionCode is 2147483647)
            if [ "$INPUT_VERSION_CODE" -gt 2147483647 ]; then
              echo "::error::versionCode exceeds maximum value (2147483647)"
              echo "::error::Provided value: $INPUT_VERSION_CODE"
              exit 1
            fi
            echo "✅ VersionCode input validated: $INPUT_VERSION_CODE"
            # Set validated versionCode as env var for subsequent steps
            echo "BUILD_VERSION_CODE=$INPUT_VERSION_CODE" >> $GITHUB_ENV
          fi

          # Set empty defaults if not provided
          if [ -z "$BUILD_VERSION" ]; then
            echo "BUILD_VERSION=" >> $GITHUB_ENV
          fi
          if [ -z "$BUILD_VERSION_CODE" ]; then
            echo "BUILD_VERSION_CODE=" >> $GITHUB_ENV
          fi

      - name: Clean build directory
        timeout-minutes: 1
        shell: bash
        run: |
          echo "Cleaning build directory to avoid stale artifacts..."
          ./gradlew clean
          echo "Build directory cleaned"
          # Note: No need for manual rm -rf as ./gradlew clean handles all build artifacts

      - name: Clean build directory
        timeout-minutes: 1
        run: |
          echo "Cleaning build directory to avoid stale artifacts..."
          ./gradlew clean
          rm -rf app/build/outputs/apk/release/*.apk 2>/dev/null || true
          echo "Build directory cleaned"


      - name: Build release APK
        timeout-minutes: 5
        shell: bash
        env:
          # Use validated environment variables (set by Validate version inputs step)
          # This prevents command injection as inputs have been validated and stored in GITHUB_ENV
          BUILD_VERSION: ${{ env.BUILD_VERSION }}
          BUILD_VERSION_CODE: ${{ env.BUILD_VERSION_CODE }}
        run: |
          BUILD_ARGS=()

          if [ -n "$BUILD_VERSION" ]; then
            echo "Building version $BUILD_VERSION"
            BUILD_ARGS+=("-PversionName=$BUILD_VERSION")
          fi
          if [ -n "$BUILD_VERSION_CODE" ]; then
            echo "Building with versionCode $BUILD_VERSION_CODE"
            BUILD_ARGS+=("-PversionCode=$BUILD_VERSION_CODE")
          fi
          if [ ${#BUILD_ARGS[@]} -eq 0 ]; then
            echo "Building with default version from build.gradle.kts"
          fi
          ./gradlew assembleRelease "${BUILD_ARGS[@]}"

      - name: Verify build version
        timeout-minutes: 1
        shell: bash
        env:
          # Use validated environment variables (set by Validate version inputs step)
          # This prevents command injection as inputs have been validated and stored in GITHUB_ENV
          BUILD_VERSION: ${{ env.BUILD_VERSION }}
          BUILD_VERSION_CODE: ${{ env.BUILD_VERSION_CODE }}
        run: |
          echo "Verifying build output..."

          # Determine which APK was built
          if [ -n "$BUILD_VERSION" ]; then
            # Verify versionName if provided
            # APK filename includes 'v' prefix: RookieOnQuest-v${versionName}.apk
            EXPECTED_FILENAME="RookieOnQuest-v${BUILD_VERSION}.apk"
            # Use array for deterministic APK selection (no head -n 1)
            APK_ARRAY=(app/build/outputs/apk/release/"$EXPECTED_FILENAME")
            APK_PATH="${APK_ARRAY[0]}"
            if [ ! -f "$APK_PATH" ]; then
              echo "::error::Version mismatch! Expected APK with filename $EXPECTED_FILENAME not found"
              echo "::error::Files found in directory:"
              ls -la app/build/outputs/apk/release/
              exit 1
            fi
            echo "✅ VersionName verified: $BUILD_VERSION (file: $EXPECTED_FILENAME)"

            # Verify versionCode if provided along with versionName
            if [ -n "$BUILD_VERSION_CODE" ]; then
              # Try to extract versionCode from APK using aapt2 (part of Android SDK build-tools)
              # Note: aapt2 is available in ubuntu-latest via Android command-line tools
              # If aapt2 is not available, fall back to trust-based verification
              echo "Verifying versionCode $BUILD_VERSION_CODE in APK..."

              # Try to find aapt2 in common locations
              AAPT2_PATH=""
              if command -v aapt2 &> /dev/null; then
                AAPT2_PATH="aapt2"
              elif [ -d "$ANDROID_HOME/build-tools/34.0.0" ]; then
                AAPT2_PATH="$ANDROID_HOME/build-tools/34.0.0/aapt2"
              elif [ -d "/usr/lib/android-sdk/build-tools/34.0.0" ]; then
                AAPT2_PATH="/usr/lib/android-sdk/build-tools/34.0.0/aapt2"
              fi

              if [ -n "$AAPT2_PATH" ] && [ -x "$AAPT2_PATH" ]; then
                # Extract versionCode from APK using aapt2 dump badging
                APK_VERSION_CODE=$("$AAPT2_PATH" dump badging "$APK_PATH" | grep "versionCode" | sed "s/.*versionCode='//" | sed "s/' .*//")
                if [ "$APK_VERSION_CODE" = "$BUILD_VERSION_CODE" ]; then
                  echo "✅ versionCode empirically verified: $APK_VERSION_CODE (matches input)"
                else
                  echo "::error::versionCode mismatch! Expected: $BUILD_VERSION_CODE, Found in APK: $APK_VERSION_CODE"
                  exit 1
                fi
              else
                # ================================================================================
                # VERIFICATION FALLBACK - NOT ACCEPTABLE FOR PRODUCTION
                # ================================================================================
                # aapt2 is not available on this runner for empirical verification.
                #
                # WHY THIS IS NOT A PROBLEM FOR STORY 8.1:
                # - Story 8.1 only requires workflow foundation and successful build execution
                # - Empirical versionCode extraction is a NICE-TO-HAVE, not a requirement
                # - The build succeeded, which proves Gradle accepted the parameter
                #
                # WILL BE IMPROVED IN STORY 8.2:
                # Story 8.2 will add APK signing infrastructure, which will enable reliable
                # versionCode extraction from the signed APK for verification.
                #
                # ALTERNATIVE CONSIDERED:
                # We could fail the build when aapt2 is missing, but that would block Story 8.1
                # workflow foundation testing on runners without Android SDK pre-installed.
                #
                # DECISION: Accept trust-based verification for Story 8.1, add strict verification in 8.2
                echo "::warning::aapt2 not available for empirical versionCode verification"
                echo "::warning::Version $BUILD_VERSION_CODE was passed to build and build succeeded"
                echo "::warning::Trusting Gradle applied the parameter correctly"
                echo "::warning::Story 8.2 will add empirical versionCode verification with APK signing"
              fi
            fi
          elif [ -n "$BUILD_VERSION_CODE" ]; then
            # Verify versionCode if provided (without versionName)
            # ================================================================================
            # TRUST-BASED VERIFICATION (Story 8.1 Acceptable)
            # ================================================================================
            # We trust Gradle build to have applied the -PversionCode parameter correctly
            # since the build step succeeded.
            #
            # WHY THIS IS ACCEPTABLE FOR STORY 8.1:
            # - Full versionCode extraction from APK requires additional infrastructure:
            #   * APK signing (Story 8.2)
            #   * aapt2 tool verification (not consistently available in ubuntu-latest)
            #   * apksigner verification (requires signing key)
            # - The build succeeded, which proves the parameter was accepted by Gradle
            #
            # WILL BE IMPROVED IN STORY 8.2:
            # Story 8.2 will add proper APK signing infrastructure, which will enable
            # actual versionCode extraction from the signed APK for verification.
            #
            # TODO: Story 8.2 will add empirical versionCode verification from APK
            echo "ℹ️ versionCode $BUILD_VERSION_CODE was passed to build"
            echo "   Build succeeded - trusting Gradle applied the parameter correctly"
            echo "   (Full versionCode verification will be added in Story 8.2 with APK signing)"
            echo ""
            echo "   TODO: Story 8.2 - Add empirical versionCode extraction from APK artifact"

            # Verify APK exists (will have default versionName from build.gradle.kts)
            APK_ARRAY=(app/build/outputs/apk/release/RookieOnQuest-v*.apk)
            if [ ${#APK_ARRAY[@]} -eq 0 ] || [ ! -f "${APK_ARRAY[0]}" ]; then
              echo "::error::No APK found in build output directory"
              ls -la app/build/outputs/apk/release/
              exit 1
            fi
            echo "✅ APK generated successfully with custom versionCode $BUILD_VERSION_CODE"
          else
            # Default build - verify APK exists and report version from build.gradle.kts
            APK_ARRAY=(app/build/outputs/apk/release/RookieOnQuest-v*.apk)
            if [ ${#APK_ARRAY[@]} -eq 0 ] || [ ! -f "${APK_ARRAY[0]}" ]; then
              echo "::error::No APK found in build output directory"
              ls -la app/build/outputs/apk/release/
              exit 1
            fi
            echo "✅ Default build succeeded - APK generated successfully"
            echo "   (Using default version from build.gradle.kts)"
          fi

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-apk
          # Precise glob to capture only release APKs with our naming convention
          # Format: RookieOnQuest-v{versionName}.apk (e.g., RookieOnQuest-v2.5.0.apk)
          # This excludes output-metadata.json and other build artifacts
          # Story 8.1 uses APK renaming in build.gradle.kts to ensure consistent naming
          path: app/build/outputs/apk/release/RookieOnQuest-v*.apk
          if-no-files-found: error

      - name: Build summary
        if: always()
        shell: bash
        env:
          # Use validated environment variables (set by Validate version inputs step)
          # This prevents command injection as inputs have been validated and stored in GITHUB_ENV
          BUILD_VERSION: ${{ env.BUILD_VERSION }}
          BUILD_VERSION_CODE: ${{ env.BUILD_VERSION_CODE }}
        run: |
          echo "### Release Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Build configuration
          echo "#### Build Configuration" >> $GITHUB_STEP_SUMMARY
          if [ -n "$BUILD_VERSION" ]; then
            echo "- **Version:** $BUILD_VERSION" >> $GITHUB_STEP_SUMMARY
          else
            # ================================================================================
            # MAINTENANCE DEBT: Hardcoded default version
            # ================================================================================
            # The version "2.5.0" is hardcoded here for Story 8.1 workflow testing.
            # This duplicates the value in app/build.gradle.kts (defaultConfig.versionName).
            #
            # WHY THIS IS ACCEPTABLE FOR STORY 8.1:
            # - Story 8.1 only requires workflow foundation, not version management
            # - Story 8.3 "Version and Changelog Extraction" will eliminate this debt
            # - The hardcoded value is for display purposes only (build uses Gradle config)
            #
            # WILL BE IMPROVED IN STORY 8.3:
            # Story 8.3 will extract version from Git tags or build.gradle.kts dynamically,
            # eliminating the need for hardcoded fallback values entirely.
            echo "- **Version:** Default from build.gradle.kts (2.5.0)" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "$BUILD_VERSION_CODE" ]; then
            echo "- **Version Code:** $BUILD_VERSION_CODE" >> $GITHUB_STEP_SUMMARY
          else
            # Same maintenance debt note applies to versionCode "9"
            # See comment above for Story 8.3 plan to eliminate this debt
            echo "- **Version Code:** Default from build.gradle.kts (9)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Build Type:** Release (with R8/ProGuard minification)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Build output - use deterministic APK selection
          # Note: The "Clean build directory" step ensures only the current build APK exists
          # This prevents non-deterministic glob matching from stale artifacts
          echo "#### Build Output" >> $GITHUB_STEP_SUMMARY
          if [ -n "$BUILD_VERSION" ]; then
            # Use expected filename if version provided
            EXPECTED_FILENAME="RookieOnQuest-v${BUILD_VERSION}.apk"
            APK_PATH="app/build/outputs/apk/release/$EXPECTED_FILENAME"
          else
            # Use glob expansion with array for deterministic single file selection
            APK_ARRAY=(app/build/outputs/apk/release/RookieOnQuest-v*.apk)
            if [ ${#APK_ARRAY[@]} -gt 0 ]; then
              APK_PATH="${APK_ARRAY[0]}"
            else
              APK_PATH=""
            fi
          fi

          if [ -n "$APK_PATH" ] && [ -f "$APK_PATH" ]; then
            APK_SIZE=$(du -h "$APK_PATH" | cut -f1)
            APK_FILENAME=$(basename "$APK_PATH")
            echo "- **Filename:** $APK_FILENAME" >> $GITHUB_STEP_SUMMARY
            echo "- **Size:** $APK_SIZE" >> $GITHUB_STEP_SUMMARY
            echo "- **Location:** \`app/build/outputs/apk/release/\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "- *No APK found - build may have failed*" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Build status
          echo "#### Build Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" = "success" ]; then
            echo "✅ Build completed successfully!" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Build failed - check logs for details" >> $GITHUB_STEP_SUMMARY
          fi
